# Интеграционные тесты биллинг-системы OK-Telecom

Этот каталог содержит интеграционные тесты для проверки взаимодействия между различными модулями системы и внешними сервисами.

## Структура тестов

### 1. `clients-lifecycle.test.ts` - Полный цикл работы с абонентами
Тестирует:
- Создание абонентов и лицевых счетов
- Управление балансом (пополнение, списание)
- Смену тарифов
- Блокировку и разблокировку счетов
- Поиск и фильтрацию
- Историю операций

### 2. `external-api.test.ts` - Интеграция с внешними API
Тестирует:
- **Robokassa API**: генерация ссылок для оплаты, обработка webhook'ов, проверка статуса платежей
- **Telegram Bot API**: отправка сообщений, обработка webhook'ов, авторизация пользователей
- **Yandex Maps API**: геокодирование адресов

### 3. `billing-cycle.test.ts` - Биллинговый цикл
Тестирует:
- Предоплатную тарификацию (месячную)
- Почасовую тарификацию
- Автоматическую блокировку при недостатке средств
- Уведомления о низком балансе
- Планировщик биллинговых задач
- Отчеты по биллингу

### 4. `notifications.test.ts` - Система уведомлений
Тестирует:
- Отправку уведомлений через Telegram
- Отправку SMS уведомлений
- Приоритетную доставку (Telegram -> SMS)
- Шаблоны уведомлений
- Массовые уведомления
- Журнал уведомлений

### 5. `kafka-integration.test.ts` - Kafka интеграция
Тестирует:
- Отправку команд в Kafka (Producer)
- Обработку команд из Kafka (Consumer)
- Интеграцию с MikroTik через Kafka
- Мониторинг выполнения команд
- Kafka Admin операции

## Настройка и запуск

### Предварительные требования

1. **MongoDB**: Тестовая база данных
2. **Переменные окружения**: Настроены в `setup.ts`
3. **Моки**: Все внешние сервисы замокированы

### Команды запуска

```bash
# Запуск всех интеграционных тестов
yarn test:integration

# Запуск только unit тестов
yarn test:unit

# Запуск всех тестов
yarn test

# Запуск с покрытием
yarn test:coverage

# Запуск в watch режиме
yarn test:watch
```

### Конфигурация Jest

Интеграционные тесты настроены как отдельный проект в `jest.config.js`:

```javascript
{
  displayName: 'integration',
  testMatch: ['<rootDir>/src/__tests__/integration/**/*.test.ts'],
  testTimeout: 60000, // Больший таймаут
  setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts']
}
```

## Структура тестового окружения

### `setup.ts` - Базовая настройка
- Настройка тестовых переменных окружения
- Моки для console методов
- Увеличенные таймауты

### `integration/setup.ts` - Настройка интеграционных тестов
- Класс `IntegrationTestSetup` для управления тестовым окружением
- Подключение к тестовой базе данных
- Создание и очистка тестовых данных
- Вспомогательные методы для создания тестовых сущностей

### `__mocks__/` - Моки внешних сервисов
- `prisma.ts` - Мок Prisma Client
- `external-services.ts` - Моки всех внешних API

### `integration/utils.ts` - Утилиты для тестов
- `TestDataUtils` - Создание сложных тестовых данных
- `HTTPTestUtils` - Утилиты для HTTP тестирования
- `AssertionUtils` - Проверки структуры данных
- `TestDataGenerator` - Генераторы случайных данных

## Принципы написания интеграционных тестов

### 1. Изоляция тестов
- Каждый тест должен быть независимым
- Очистка данных после каждого теста
- Использование уникальных идентификаторов

### 2. Реалистичные сценарии
- Тесты должны имитировать реальные пользовательские сценарии
- Проверка полного цикла операций
- Тестирование граничных случаев

### 3. Моки внешних сервисов
- Все внешние API должны быть замокированы
- Моки должны имитировать различные сценарии (успех, ошибки)
- Проверка правильности вызовов внешних API

### 4. Производительность
- Использование `runInBand` для последовательного выполнения
- Оптимизация создания тестовых данных
- Разумные таймауты

## Примеры использования

### Создание тестового клиента с несколькими счетами

```typescript
const { client, accounts } = await testSetup.createClientWithAccounts(3);
```

### Авторизация в тестах

```typescript
const authToken = await httpUtils.authenticate();
const request = httpUtils.createAuthorizedRequest(authToken);
```

### Проверка структуры ответа

```typescript
AssertionUtils.expectApiResponse(response.body, {
  id: expect.any(String),
  balance: expect.any(Number),
  status: 'ACTIVE'
});
```

### Ожидание асинхронных операций

```typescript
await httpUtils.waitForCondition(async () => {
  const account = await testSetup.prisma.account.findUnique({
    where: { id: accountId }
  });
  return account?.status === 'BLOCKED';
}, 5000);
```

## Отладка тестов

### Логирование
- Используйте `console.log` для отладки (замокирован в тестах)
- Проверяйте логи в `packages/app-server/logs/`

### Проверка базы данных
- Используйте `testSetup.prisma` для прямых запросов к БД
- Проверяйте состояние данных между операциями

### Моки
- Используйте `jest.clearAllMocks()` в `beforeEach`
- Проверяйте вызовы моков с помощью `expect().toHaveBeenCalledWith()`

## Покрытие тестами

Интеграционные тесты должны покрывать:

- ✅ Полные пользовательские сценарии
- ✅ Интеграцию между модулями
- ✅ Обработку ошибок
- ✅ Внешние API
- ✅ Асинхронные операции
- ✅ Бизнес-логику

## Добавление новых тестов

1. Создайте новый файл в `integration/`
2. Используйте `setupIntegrationTests()` и `teardownIntegrationTests()`
3. Импортируйте тест в `integration/index.test.ts`
4. Добавьте необходимые моки в `__mocks__/`
5. Обновите документацию

## Troubleshooting

### Тесты падают с таймаутом
- Увеличьте `testTimeout` в конфигурации
- Проверьте, что все асинхронные операции завершаются
- Используйте `await` для всех промисов

### Ошибки подключения к БД
- Проверьте `DATABASE_URL` в переменных окружения
- Убедитесь, что MongoDB запущен
- Проверьте права доступа к тестовой БД

### Конфликты данных
- Используйте уникальные идентификаторы
- Очищайте данные в `afterEach` или `afterAll`
- Проверьте порядок выполнения тестов

### Проблемы с моками
- Убедитесь, что моки сброшены в `beforeEach`
- Проверьте правильность путей в `jest.mock()`
- Используйте `jest.clearAllMocks()` для сброса состояния